---
title: "Preoperative Atelectasis"
author: "Javier Mancilla Galindo"
date: last rendered on "`r Sys.Date()`"
output: 
  html_document:
    toc: true
    toc_float: true
    theme: default
    highlight: pygments
---

# Setup 
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE) #show both code and output by default
knitr::opts_chunk$set(warning=FALSE) #hides all warnings
knitr::opts_chunk$set(message=FALSE) #hides all package message
```

#### Load packages  
```{r}
if ( !require("pacman", quietly = TRUE) )
    install.packages("pacman")

pacman::p_load(
  tidyverse, #Used for basic data handling and visualization.  
  RColorBrewer, #Color palettes for data visualization. 
  gridExtra, #Used to arrange multiple ggplots in a grid.  
  grid, #Used to arrange multiple ggplots in a grid.
  overviewR, #Used to assess missing data.  
  rnaturalearth, #Used to extract geographical data to create maps. 
  sf, #Used together with the prior package to create map. 
  plotly, #Used together with prior two packages to create map.  
  table1, #Used to add labels to variables and to create table of descriptive characteristics of patients.
  flextable, #Used to export tables.  
  officer,  #Used to export tables.
  mgcv, #Used to model non-linear relationships with a general additive model.  
  ggmosaic, #Used to create mosaic plots.   
  car, #Used to visualize distribution of continuous variables (stacked Q-Q plots).
  simpleboot, #Used to calculate mean atelectasis coverage and confidence intervals trhough bootstrapping. 
  boot, #Used to calculate mean atelectasis coverage and confidence intervals trhough bootstrapping.
  dagitty, #Used in conjunction with https://www.dagitty.net/ to create directed acyclic graph to inform statistical modelling.
  lavaan, #Used to create correlation matrix to assess conditional independencies.  
  broom, #Used to exponentiate coefficients of regression models. 
  sandwich, #Used to calculate robust standard errors for prevalence ratios.  
  ordinal, #Used to model ordinal outcome (atelectasis percent) and to test proportional odds assumptions.  
  VGAM, #Used to model partial proportional odds model.   
  gt, #Used to present a summary of the results of regression models.   
  gtsummary, #Used to create table to summarize regression models.  
  gratia #Used together with gglopt2 to create smooth partial effects plot from gam models. 
)
```

Set seed (needed for reproducibility of bootstrapping) as the current year 2023:   
```{r}
set.seed(2023)
```


# Statistical Modelling    
Plot DAG model to visualizes again:    
```{r}
plot(DAG)
```

## Implied conditional independencies in DAG:  

This procedure was performed as suggested in [this article](https://doi.org/10.1002/cpz1.45).  

```{r, echo=FALSE}
impliedConditionalIndependencies(DAG)
```

Test conditional independencies:
```{r}
subsetcondit <- datamodel %>% select(c("age",
                                       "sex",
                                       "type_obesity",
                                       "spo2_VPO",
                                       "hb",
                                       "sleep_apnea",
                                       "atelectasis_percent",
                                       "altitude_cat")
                                     ) 

subsetcondit <- subsetcondit %>% 
  mutate(sex = as.numeric(sex),
         sleep_apnea = as.numeric(sleep_apnea)
         )

corr <- lavCor(subsetcondit,
               ordered=c("sex",
                         "type_obesity",
                         "sleep_apnea",
                         "atelectasis_percent",
                         "altitude_cat",
                         "spo2_VPO")
               )

corr
```


```{r}
localtests <- localTests(DAG, sample.cov=corr, sample.nobs=nrow( subsetcondit ) )
localtests
```

```{r}
plotLocalTestResults(localtests)
```

Conditional independence assumption OK. Minimal set of adjustment is ***age***, ***sex***, and ***sleep_apnea***.       

```{r, include=FALSE}
rm(corr,localtests,subsetcondit)
```


# Prevalence Ratio   
This [paper](https://doi.org/10.1016/j.annepidem.2023.08.001) and accompanying code were used to calculate prevalence ratios.    

A modified Poisson regression model with robust errors will be applied to obtain prevalence ratios.

## Crude prevalence ratio   
```{r}
dataprev <- data %>% 
  mutate(atelectasis = as.numeric(
    as.character(
      fct_recode(atelectasis,
                 "0"="No",
                 "1"="Yes"))))


poisson_fit <- glm(atelectasis ~ type_obesity,
                   data = dataprev,
                   family = poisson(link = log)
                   )

tidy(poisson_fit, exponentiate = TRUE, conf.int = TRUE)
```

Robust standard errors:  
```{r}
covmat <- vcovHC(poisson_fit, type = "HC0")
covmat
```

```{r}
#Calculate the standard error
se <- sqrt(diag(covmat))

# Bind together model output
#  1. exponentiated coefficients
#  2. robust standard errors
#  3. 95% confidence intervals
# Note that qnorm(0.975) approximately equals 1.96
model_output <- cbind(
  Estimate = exp(coef(poisson_fit)),
  `Robust SE` = se,
  Lower = exp(coef(poisson_fit) - qnorm(0.975) * se),
  Upper = exp(coef(poisson_fit) + qnorm(0.975) * se)
)

# Coerce model_output into a data frame
model_output <- as.data.frame(round(model_output,2))
model_output
```

## Adjusted prevalence ratio   
```{r}
poisson_fit <- glm(atelectasis ~ type_obesity + age + sex + sleep_apnea,
data = dataprev,
family = poisson(link = log))

tidy(poisson_fit, exponentiate = TRUE, conf.int = TRUE)
```

Robust standard errors:  
```{r}
covmat <- vcovHC(poisson_fit, type = "HC0")
covmat
```

```{r}
#Calculate the standard error
se <- sqrt(diag(covmat))

# Bind together model output
#  1. exponentiated coefficients
#  2. robust standard errors
#  3. 95% confidence intervals
# Note that qnorm(0.975) approximately equals 1.96
model_output2 <- cbind(
  Estimate = exp(coef(poisson_fit)),
  `Robust SE` = se,
  Lower = exp(coef(poisson_fit) - qnorm(0.975) * se),
  Upper = exp(coef(poisson_fit) + qnorm(0.975) * se)
)

# Coerce model_output into a data frame
model_output2 <- as.data.frame(round(model_output2,2))
model_output2
```

### Table 2   
```{r}
model_output <- model_output %>% 
  dplyr::slice(2:3) %>%
  rename(PR = Estimate, SE = `Robust SE`) %>% 
  mutate("95%CI" = paste(Lower,Upper,sep="-")) %>% 
  select(-c(Lower,Upper))

model_output2 <- model_output2 %>% 
  dplyr::slice(2:3) %>%
  rename(aPR = Estimate, aSE = `Robust SE`) %>% 
  mutate("a95%CI" = paste(Lower,Upper,sep="-")) %>% 
  select(-c(Lower,Upper))

table2 <- dplyr::bind_cols(model_output, model_output2) %>% 
  rownames_to_column(var = "Category") %>% 
  mutate_at("Category", str_replace, "type_obesity", "")

flextable(table2) %>% 
  save_as_docx(path = paste(tabfolder,"/Table2.docx",sep=""))

table2
```


```{r, include=FALSE}
rm(dataprev,poisson_fit,covmat,se,model_output, model_output2,table2)
```


# Ordinal Logistic Regression Model   

Some code available in the following [resource](https://tdunn.ca/posts/2020-03-15-ordinal-regression-in-r-part-1) was used for these analyses:   
- Dunn, Taylor. 2020. “Ordinal Regression in R: Part 1.” March 15, 2020.    


Rename type obesity levels to facilitate reading of results:  
```{r}
datamodel <- datamodel %>% 
  mutate(type_obesity=fct_recode(type_obesity,
                                 "1"="Class 1 Obesity",
                                 "2"="Class 2 Obesity",
                                 "3"="Class 3 Obesity"),
         atelectasis_percent=ordered(atelectasis_percent)
         ) 
```

Visualize pattern of atelectasis percent increase by obesity type category.  
```{r}
datamodel %>% 
  ggplot(aes(x = type_obesity, fill = atelectasis_percent)) + 
  geom_bar() +  
  scale_fill_manual(values = brewer.pal(8,"Blues")) + 
  theme_minimal()
```

## Univariable models   

The **loglog** link function will be used for all models since this distribution provides the best fit for the fully adjusted model:   

```{r}
datamodel %>%
  nest(data = everything()) %>%
 crossing(
    link = c("logit", "probit", "cloglog", "loglog", "cauchit"),
    threshold = c("flexible", "equidistant", "symmetric", "symmetric2")
  ) %>%
  mutate(
    mod = map2(
      data, link,
      ~clm(atelectasis_percent ~ type_obesity + sex + age + sleep_apnea, 
        data = .x, link = .y
      )
    )
  ) %>%
  mutate(
    mod_summary = map(
      mod,
      ~glance(.x) %>% mutate(logLik = as.numeric(logLik))
    )
  ) %>%
  unnest(mod_summary) %>%
  dplyr::select(link, threshold, logLik, edf, AIC, BIC) %>%
  arrange(logLik) %>%
  gt()
```

Obesity class:   
```{r, warning=TRUE}
fit_BMI <- clm(atelectasis_percent~type_obesity,
               data = datamodel, 
               link = "loglog", threshold = "flexible")

summary(fit_BMI)
```

```{r, warning=TRUE}
nominal_test(fit_BMI)
scale_test(fit_BMI)
```

Output not showing result of nominal test. When running traceback, this seems to be a problem of failure to converge of the nominal test function. However, this does not constitute a problem in the model convergence itself as shown bellow:   
```{r}
convergence(fit_BMI)
```

This problem has been signalled in [post1](https://stats.stackexchange.com/questions/411618/why-is-my-output-for-nominal-test-incomplete) and [post2](https://github.com/runehaubo/ordinal/issues/15), without an available solution yet within the package. However, running a model with a nominal term for the explanatory variable and comparing them trough ANOVA is an alternative way of testing the proportional odds assumption:   

```{r, warning=TRUE}
fit_BMInom <- clm(atelectasis_percent ~ 1, nominal= ~ type_obesity, 
                  data = datamodel, 
                  link = "loglog", threshold = "flexible")

summary(fit_BMInom)
```

Nominal model failed to converge, likely due to many new subgroups needed to create a nominal model, many of which may have been empty. 

One additional problem that may have led to the inability to test the proportional odds assumption is that there is one category with only one observation:  
```{r}
table(datamodel$atelectasis_percent)
```

It is known that having few observations per category does not affect the results of ordinal regression, and that some categories may need to be combined to assess proportional odds assumption. [REF](https://stats.stackexchange.com/q/48844)

Will collapse categories to test:  
```{r}
data_prop <- datamodel 
data_prop$atelectasis_percent <- fct_collapse(data_prop$atelectasis_percent,
                                              "0%" = c("0%","2.5%"),
                                              "5%" = c("5%","7.5%"),
                                              "10%" = c("10%","12.5%"),
                                              "15%" = c("15%","17.5%")
                                              )

table(data_prop$atelectasis_percent)
```

```{r, warning=TRUE}
fit_BMI2 <- clm(atelectasis_percent~type_obesity,
                data = data_prop, 
                link = "loglog", threshold = "flexible")

summary(fit_BMI2)
```

```{r, warning=TRUE}
nominal_test(fit_BMI2)
scale_test(fit_BMI2)
```

```{r, warning=TRUE}
fit_BMInom2 <- clm(atelectasis_percent ~ 1, nominal= ~ type_obesity, 
                   data = data_prop, 
                   link = "loglog", threshold = "flexible")

summary(fit_BMInom2)
```

```{r, warning=TRUE}
anova(fit_BMI2,fit_BMInom2)
```

The model with nominal effects has a marginally lower AIC (360.05) than the ordinal model (363.66) p=0.02. Proportional odds assumption not met. However, nominal model had problem with convergence (unstable estimates).    

One alternative would be to fully model through a multinomial logistic regression model. As already shown, nominal models have failed to converge and have reduced statistical power.    

Other alternatives would be to "ignore non-proportional odds, knowing that the odds ratio may still be very meaningful, or fit a partial proportional odds model or constrained partial PO model using either Bayesian modeling with blrm or using a frequentist procedure with the VGAM package vglm function" [REF1](https://discourse.datamethods.org/t/ordinal-regression-when-odds-are-not-proportional/4550) plus [REF2](https://www.fharrell.com/post/po/).   

Despite not meeting proportional odds assumption, I will present results of univariable and multivariable ordinal regression models to present first-order effects since this model is parsimonious and easier to understand. I will then try to create a partial PO model to further characterize and understand exposure-effect relationships.   

### Covariates univariable models    

Age   
```{r}
fit_age <- clm(atelectasis_percent~age,
               data = datamodel, 
               link = "loglog", threshold = "flexible")

summary(fit_age)
```

```{r}
nominal_test(fit_age)
scale_test(fit_age)
```

Proportional odds assumption not showing either. Perhaps this is a problem due to centering. Will center and re-assess.   

```{r}
datamodel <- datamodel %>% mutate(agec = age/mean(age))
```

```{r}
fit_age2 <- clm(atelectasis_percent~agec,
                data = datamodel, 
                link = "loglog", threshold = "flexible")

summary(fit_age2)
```

```{r}
nominal_test(fit_age2)
scale_test(fit_age2)
```

Still not shown. Nonetheless, proportional odds assumption is not quite as relevant for covariates. Will assess remaining variables to decide best approach.      

```{r}
uni_age <- tidy(fit_age, conf.int = T, conf.type = "Wald") %>%
  transmute(
    term, across(c(estimate, conf.low, conf.high), exp)
  ) %>%
  gt() %>%
  fmt_number(c(estimate, conf.low, conf.high), decimals = 2) %>% 
  cols_merge(c(conf.low, conf.high),
             pattern = "{1}&mdash;{2}") %>% 
   cols_label(conf.low = "95%CI")

uni_age
```


Sex     
```{r}
fit_sex <- clm(atelectasis_percent~sex,
               data = datamodel, 
               link = "loglog", threshold = "flexible")

summary(fit_sex)
```

```{r}
nominal_test(fit_sex)
scale_test(fit_sex)
```

Does not hold for sex either.   

```{r}
uni_sex <- tidy(fit_sex, conf.int = T, conf.type = "Wald") %>%
  transmute(
    term, across(c(estimate, conf.low, conf.high), exp)
  ) %>%
  gt() %>%
  fmt_number(c(estimate, conf.low, conf.high), decimals = 2) %>% 
  cols_merge(c(conf.low, conf.high),
             pattern = "{1}&mdash;{2}") %>% 
  cols_label(conf.low = "95%CI")

 uni_sex
```


Sleep Apnea        
```{r}
fit_OSA <- clm(atelectasis_percent~sleep_apnea,
               data = datamodel, link = "loglog", 
               threshold = "flexible")

summary(fit_OSA)
```

```{r}
nominal_test(fit_OSA)
scale_test(fit_OSA)
```

Does not hold for OSA either.   

```{r}
uni_OSA <- tidy(fit_OSA, conf.int = T, conf.type = "Wald") %>%
  transmute(
    term, across(c(estimate, conf.low, conf.high), exp)
  ) %>%
  gt() %>%
  fmt_number(c(estimate, conf.low, conf.high), decimals = 2)  %>% 
  cols_merge(c(conf.low, conf.high),
             pattern = "{1}&mdash;{2}") %>% 
  cols_label(conf.low = "95%CI")

uni_OSA
```


```{r, include=FALSE}
rm(uni_age,uni_BMI,uni_OSA,uni_sex,fit_age,fit_BMI,fit_BMInom,fit_OSA,fit_sex)
```



## Ordinal (collapsed factors) Logistic Regression 

Since proportional odds not met for prior model with multiple ordered categories, I will use the priorly collapsed categories to model since AIC was also much lower when including collapsed factors. Perhaps this solves problems in prior models?   

### Univariable models    

Type obesity (ordinal model created before)      
```{r}
uni_BMI <- tidy(fit_BMI2, conf.int = T, conf.type = "Wald") %>%
  transmute(
    term, across(c(estimate, conf.low, conf.high), exp)
  ) %>%
  gt() %>%
  fmt_number(c(estimate, conf.low, conf.high), decimals = 2) %>% 
  cols_merge(c(conf.low, conf.high),
             pattern = "{1}&mdash;{2}") %>% 
   cols_label(conf.low = "95%CI")

uni_BMI
```


Age   
```{r}
fit_age <- clm(atelectasis_percent~age,
               data = data_prop, 
               link = "loglog", threshold = "flexible")

summary(fit_age)
```

```{r}
nominal_test(fit_age)
scale_test(fit_age)
```

Proportional odds assumption not showing either. Will try centered variable.   

```{r}
data_prop <- data_prop %>% mutate(agec = age/mean(age))
```

```{r}
fit_age2 <- clm(atelectasis_percent~agec,
                data = data_prop, 
                link = "loglog", threshold = "flexible")

summary(fit_age2)
```

```{r}
nominal_test(fit_age2)
scale_test(fit_age2)
```

Still not shown. Nonetheless, proportional odds assumption is not quite as relevant for covariates. Will assess remaining variables to decide best approach.      

```{r}
uni_age <- tidy(fit_age, conf.int = T, conf.type = "Wald") %>%
  transmute(
    term, across(c(estimate, conf.low, conf.high), exp)
  ) %>%
  gt() %>%
  fmt_number(c(estimate, conf.low, conf.high), decimals = 2) %>% 
  cols_merge(c(conf.low, conf.high),
             pattern = "{1}&mdash;{2}") %>% 
   cols_label(conf.low = "95%CI")

uni_age
```


Sex     
```{r}
fit_sex <- clm(atelectasis_percent~sex,
               data = data_prop, 
               link = "loglog", threshold = "flexible")

summary(fit_sex)
```

```{r}
nominal_test(fit_sex)
scale_test(fit_sex)
```

Sex OK.   

```{r}
uni_sex <- tidy(fit_sex, conf.int = T, conf.type = "Wald") %>%
  transmute(
    term, across(c(estimate, conf.low, conf.high), exp)
  ) %>%
  gt() %>%
  fmt_number(c(estimate, conf.low, conf.high), decimals = 2) %>% 
  cols_merge(c(conf.low, conf.high),
             pattern = "{1}&mdash;{2}") %>% 
  cols_label(conf.low = "95%CI")

 uni_sex
```


Sleep Apnea        
```{r}
fit_OSA <- clm(atelectasis_percent~sleep_apnea,
               data = data_prop, 
               link = "loglog", threshold = "flexible")

summary(fit_OSA)
```

```{r}
nominal_test(fit_OSA)
scale_test(fit_OSA)
```

OSA OK.   

```{r}
uni_OSA <- tidy(fit_OSA, conf.int = T, conf.type = "Wald") %>%
  transmute(
    term, across(c(estimate, conf.low, conf.high), exp)
  ) %>%
  gt() %>%
  fmt_number(c(estimate, conf.low, conf.high), decimals = 2)  %>% 
  cols_merge(c(conf.low, conf.high),
             pattern = "{1}&mdash;{2}") %>% 
  cols_label(conf.low = "95%CI")

uni_OSA
```



```{r, include=FALSE}
rm(uni_age,uni_BMI,uni_OSA,uni_sex,fit_age,fit_BMI,fit_BMInom,fit_OSA,fit_sex,fit_BMI2,fit_BMInom2,fit_age2)
```

This modelling approach with collapsed factors is way more stable. Thus, will proceed with this modelling approach.   

## Multivariable model   

```{r, warning=TRUE}
fit_multi <- clm(atelectasis_percent ~ type_obesity + age + sex + sleep_apnea,
                 data = data_prop, 
                 link = "loglog", threshold = "flexible")

summary(fit_multi)
```

Convergence: 
```{r}
convergence(fit_multi)
```


Check proportional odds assumption:   
```{r, warning=TRUE}
nominal_test(fit_multi)
```

Proportional odds OK for all variables except obesity type (as already expected) and age, but proportional odds assumption is not as relevant for covariates.  

Check for scale effects:    
```{r}
scale_test(fit_multi)
```

No scale effects, good news.   

Summarize results in table:   
```{r}
tidy(fit_multi, conf.int = T, conf.type = "Wald") %>%
  transmute(
    term, across(c(estimate, conf.low, conf.high), exp)
  ) %>%
  gt() %>%
  fmt_number(c(estimate, conf.low, conf.high), decimals = 2) %>% 
  cols_merge(c(conf.low, conf.high),
             pattern = "{1}&mdash;{2}") %>% 
  cols_label(conf.low = "95%CI")
```


```{r, include=FALSE}
rm(fit_multi)
```



# Partial proportional odds model:   

As mentioned before, a partial proportional odds model could be useful in understanding patterns leading to not meeting proportional odds assumption. Thus, I will fit a partial proportional odds model.   

The **loglog** function remains the better function to fit a model with nominal component for type_obesity.   
```{r}
data_prop %>%
  nest(data = everything()) %>%
 crossing(
    link = c("logit", "probit", "cloglog", "loglog", "cauchit"),
    threshold = c("flexible", "equidistant")
  ) %>%
  mutate(
    mod = map2(
      data, link,
      ~clm(atelectasis_percent ~ sex + age + sleep_apnea, nominal = ~ type_obesity,
        data = .x, link = .y
      )
    )
  ) %>%
  mutate(
    mod_summary = map(
      mod,
      ~glance(.x) %>% mutate(logLik = as.numeric(logLik))
    )
  ) %>%
  unnest(mod_summary) %>%
  dplyr::select(link, threshold, logLik, edf, AIC, BIC) %>%
  arrange(logLik) %>%
  gt()
```

## Univariable model     
```{r}
fit_BMIpartuni <- vglm(atelectasis_percent ~ type_obesity, 
                       data=data_prop, link="loglog",
                       family=cumulative(parallel=FALSE~type_obesity, reverse = TRUE)
                       )

summary(fit_BMIpartuni)
```

```{r}
confint_BMIpartuni <- round(exp(confintvglm(fit_BMIpartuni,method = "wald")),2)
confint_BMIpartuni
```

## Multivariable model  
Fit a model that allows proportional odds for all explanatory variables, except type obesity:    
```{r}
fit_BMIpart <- vglm(atelectasis_percent ~ type_obesity+sleep_apnea+sex+age, 
                    data=data_prop, 
                    link="loglog", 
                    family=cumulative(parallel=FALSE~type_obesity, reverse = TRUE)
                    )

summary(fit_BMIpart)
```


```{r}
AIC(fit_BMIpart)
```

```{r}
confint_BMIpart <- round(exp(confintvglm(fit_BMIpart,method = "wald")),2)
confint_BMIpart
```

```{r, include=FALSE}
rm(fit_BMIpart,confint_BMIpart,fit_BMIpartuni,confint_BMIpart)
```



# Model SpO2   

The SpO2 variable does not have a normal distribution. Furthermore, the distance between 1% increases in SpO2 cannot be considered equidistant increases since values are determined from the S-shaped curve of hemoglobin saturation. This is the reason why the distribution of SpO2 is negatively skewed, with upper values reaching the saturation point of the hemoglobin curve. 

Therefore, modelling SpO2 as a linear term could be potentially misleading. Nonetheless, a model assuming a gaussian distribution for SpO2 may potentially be easier to understand and communicate. 

Thus, I will first model SpO2 assuming a gaussian distribution and I will then apply a fractional regression model which is more appropriate for the distribution of this variable. If assuming a gaussian distribution does not change the conclusions with respect to the more appropriate fractional model, then I will report the earlier. If results are discordant, then I will report the fractional model, instead.    



## Model assuming gaussian distribution      

Create variable with atelectasis percent as numeric to be able to model with smooth term:   
```{r}
datamodel <- datamodel %>% 
  mutate(atelectasis_smooth = as.numeric(atelectasis_percent))
```


First, I will fit an empty model    
```{r}
model <- gam(spo2_VPO ~ 1, 
           data=datamodel
           )
AIC_empty <- AIC(model)
R2_empty <- summary(model)$r.sq
dev_empty <- summary(model)$dev.expl

summary(model)
```

Fit again GAM with only smooth BMI term (the one used for Figure 1a):   
```{r}
model_BMI <- gam(spo2_VPO ~ s(BMI,k=5), 
                 data=datamodel
                 )

AIC_BMI <- AIC(model_BMI)
R2_BMI <- summary(model_BMI)$r.sq
dev_BMI <- summary(model_BMI)$dev.expl

summary(model_BMI)
plot(model_BMI)
```

```{r}
gam.check(model_BMI)
```

Fit a model that only contains OSA:   
```{r}
model_OSA_only <- gam(spo2_VPO ~ sleep_apnea, 
                    data=datamodel
                    )

AIC_OSA_only <- AIC(model_OSA_only)
R2_OSA_only <- summary(model_OSA_only)$r.sq
dev_OSA_only <- summary(model_OSA_only)$dev.expl

summary(model_OSA_only)
```

```{r}
gam.check(model_OSA_only)
```


Fit a model that only contains atelectasis percent as smooth term:    
```{r}
model_atel_smooth <- gam(spo2_VPO ~ s(atelectasis_smooth,k=4),
                       data=datamodel
                       )

AIC_atel_smooth <- AIC(model_atel_smooth)
R2_atel_smooth <- summary(model_atel_smooth)$r.sq
dev_atel_smooth <- summary(model_atel_smooth)$dev.expl

summary(model_atel_smooth)
```

```{r}
gam.check(model_atel_smooth)
```

Compare against atelectasis_percent as categorical. Will not model as ordinal as coefficients are more difficult to interpret than nominal terms. Whether this variable is entered as nominal or ordinal does not change the results of models. This can be checked by converting atelectasis percent to ordered and back to unordered, which I did as corroboration.     

```{r}
datamodel <- datamodel %>% mutate(
  atelectasis_percent = factor(atelectasis_percent, ordered = FALSE)
  )
```

   
```{r}
model_atel_only <- gam(spo2_VPO ~ atelectasis_percent, 
                     data=datamodel
                     )

AIC_atel_only <- AIC(model_atel_only)
R2_atel_only <- summary(model_atel_only)$r.sq
dev_atel_only <- summary(model_atel_only)$dev.expl

summary(model_atel_only)
```

```{r}
gam.check(model_atel_only)
```

Modelling with smooth term offers improvement in aR2 and drop in AIC. Nonetheless, since this a non-linear relationship between BMI and the outcome is being studied, the explained deviance is more informative. Since categorical atelectasis percent explains greater deviance, I will continue using it as categorical for the subsequent models.        

Fit model sBMI plus atelectasis percentage:      
```{r}
model_atel <- gam(spo2_VPO ~ s(BMI,k=5) + s(atelectasis_smooth,k=5), 
                data=datamodel
                )

AIC_atel <- AIC(model_atel)
R2_atel <- summary(model_atel)$r.sq
dev_atel <- summary(model_atel)$dev.expl

summary(model_atel)
plot(model_atel, all.terms=TRUE)
```

```{r}
gam.check(model_atel)
```

Model sleep apnea plus sBMI:    
```{r}
model_OSA <- gam(spo2_VPO ~ s(BMI,k=5) + sleep_apnea,
                 data=datamodel
                 )

AIC_OSA <- AIC(model_OSA)
R2_OSA <- summary(model_OSA)$r.sq
dev_OSA <- summary(model_OSA)$dev.expl

summary(model_OSA)
plot(model_OSA, all.terms=TRUE)
```

```{r}
gam.check(model_OSA)
```

Model sBMI + sleep apnea + atelectasis percent:      
```{r}
model_OSA_atel <- gam(spo2_VPO ~ s(BMI,k=5) +
                        sleep_apnea + s(atelectasis_smooth,k=5),
                      data=datamodel
                      )

AIC_OSA_atel <- AIC(model_OSA_atel)
R2_OSA_atel <- summary(model_OSA_atel)$r.sq
dev_OSA_atel <- summary(model_OSA_atel)$dev.expl

summary(model_OSA_atel)
plot(model_OSA_atel, all.terms=TRUE)
```

```{r}
gam.check(model_OSA_atel)
```

Fit model adjusted for confounders:   
```{r}
model_adj <- gam(spo2_VPO ~ s(BMI,k=5) +
                   sex + age + sleep_apnea + hb + altitude_cat,
                 data=datamodel, na.action=na.omit
                 )


AIC_adj <- AIC(model_adj)
R2_adj <- summary(model_adj)$r.sq
dev_adj <- summary(model_adj)$dev.expl

summary(model_adj)
plot(model_adj, all.terms=TRUE)
```

```{r}
gam.check(model_adj)
```

Fit adjusted model plus atelectasis percentage:       
```{r}
model_plus <- gam(spo2_VPO ~ s(BMI,k=5) +
                    sex + age + sleep_apnea + hb + altitude_cat +
                    atelectasis_percent,
                  data=datamodel, na.action=na.omit
                  )

AIC_plus <- AIC(model_plus)
R2_plus <- summary(model_plus)$r.sq
dev_plus <- summary(model_plus)$dev.expl

summary(model_plus)
plot(model_plus, all.terms=TRUE)
```

```{r}
gam.check(model_plus)
```



Build a dataframe to compare models:  
```{r}
models <- data.frame(Model = c("empty",
                               "sBMI",
                               "OSA_only",
                               "atel_only",
                               "s(atel)",
                               "sBMI_atel",
                               "sBMI_OSA",
                               "sBMI_atel_OSA",
                               "adjusted",
                               "adjusted_plus_atel"),
                     AIC = c(AIC_empty,
                             AIC_BMI,
                             AIC_OSA_only,
                             AIC_atel_only,
                             AIC_atel_smooth,
                             AIC_atel,
                             AIC_OSA,
                             AIC_OSA_atel,
                             AIC_adj,
                             AIC_plus),
                     aR2 = c(R2_empty,
                             R2_BMI,
                             R2_OSA_only,
                             R2_atel_only,
                             R2_atel_smooth,
                             R2_atel,
                             R2_OSA,
                             R2_OSA_atel,
                             R2_adj,
                             R2_plus),
                     dev = c(dev_empty,
                             dev_BMI,
                             dev_OSA_only,
                             dev_atel_only,
                             dev_atel_smooth,
                             dev_atel,
                             dev_OSA,
                             dev_OSA_atel,
                             dev_adj,
                             dev_plus)
                     )
```

Sort by AIC
```{r}
models %>% arrange(AIC)
```

Sort by deviance   
```{r}
models <- models %>% mutate(aR2 = round(aR2,3)*100,
                            dev = round(dev,3)*100
                            )
models %>% arrange(desc(dev))
```

Sort by adjusted R2
```{r}
models %>% arrange(desc(aR2))
```

Some conclusions from model assuming normal distribution for SpO2:   
- Most of the effect of BMI was atenuated when including atelectasis percent. Nonetheless, a smooth term for BMI was still statistically significant in adjusted models.  Will check if these conclusions hold in the more appropriate fractional model.    
- There were problems with heteroskedasticity using Gaussian function, with greater error higher SpO2 values. Notably, error term at lower SpO2 values was low, meaning that the terms included in the model very likely explain most of the variability at low SpO2 values. This could make sense, as it is unlikely that normal SpO2 values will be explained by these factors. Thus, it may be a case of true heteroskedasticity. Will again check in fractional model.    

```{r, include = FALSE}
rm(list=setdiff(ls(pattern = "^AIC"), lsf.str()))
rm(list=setdiff(ls(pattern = "^dev"), lsf.str()))
rm(list=setdiff(ls(pattern = "^model"), lsf.str()))
rm(list=setdiff(ls(pattern = "^R2"), lsf.str()))
```


## Fractional regression function    

Convert SpO2 to fractional values between 0 and 1 to model.   
```{r}
datamodel <- datamodel %>% mutate(spo2_fraction = spo2_VPO/100)
```

#### Empty model   
First, I will fit an empty model    
```{r}
model<-gam(spo2_fraction~1,
           data=datamodel, 
           family = quasibinomial(link = logit)
           )

R2_empty <- summary(model)$r.sq
dev_empty <- summary(model)$dev.expl

summary(model)
```
#### Smooth BMI   
Fit again GAM with only smooth BMI term (the one used for Figure 1a):   
```{r}
model_BMI <- gam(spo2_fraction~s(BMI,k=5), 
                 data=datamodel, 
                 family = quasibinomial(link = logit)
                 )

R2_BMI <- summary(model_BMI)$r.sq
dev_BMI <- summary(model_BMI)$dev.expl

summary(model_BMI)
plot(model_BMI)
```

```{r}
gam.check(model_BMI)
```

#### OSA only
Fit a model that only contains OSA:   
```{r}
model_OSA_only<-gam(spo2_fraction~sleep_apnea,
                    data=datamodel,
                    family = quasibinomial(link = logit)
                    )

R2_OSA_only <- summary(model_OSA_only)$r.sq
dev_OSA_only <- summary(model_OSA_only)$dev.expl

summary(model_OSA_only)
```

```{r}
gam.check(model_OSA_only)
```

#### Atelectasis percent   
Fit a model that only contains atelectasis percent:    
```{r}
model_atel_only<-gam(spo2_fraction ~ atelectasis_percent,
                     data=datamodel, 
                     family = quasibinomial(link = logit)
                     )

R2_atel_only <- summary(model_atel_only)$r.sq
dev_atel_only <- summary(model_atel_only)$dev.expl

summary(model_atel_only)
```

```{r}
gam.check(model_atel_only)
```

#### s(BMI) + atelectasis percentage    
Fit model sBMI plus atelectasis percentage:      
```{r}
model_atel<-gam(spo2_fraction ~ s(BMI,k=5) + atelectasis_percent,
                data=datamodel, 
                family = quasibinomial(link = logit)
                )

R2_atel <- summary(model_atel)$r.sq
dev_atel <- summary(model_atel)$dev.expl

summary(model_atel)
plot(model_atel, all.terms=TRUE)
```

```{r}
gam.check(model_atel)
```

### OSA + BMI    
Model sleep apnea plus sBMI:    
```{r}
model_OSA <- gam(spo2_fraction ~ s(BMI,k=5) + sleep_apnea, 
               data=datamodel, 
               family = quasibinomial(link = logit)
               )

R2_OSA <- summary(model_OSA)$r.sq
dev_OSA <- summary(model_OSA)$dev.expl

summary(model_OSA)
plot(model_OSA, all.terms=TRUE)
```

### sBMI + OSA + atelectasis percent 
Model sBMI + sleep apnea + atelectasis percent:      
```{r}
model_OSA_atel <-gam(spo2_fraction ~ s(BMI,k=5) + sleep_apnea + 
                       atelectasis_percent,
                     data=datamodel, 
                     family = quasibinomial(link = logit)
                     )

R2_OSA_atel <- summary(model_OSA_atel)$r.sq
dev_OSA_atel <- summary(model_OSA_atel)$dev.expl

summary(model_OSA_atel)
plot(model_OSA_atel, all.terms=TRUE)
```

```{r}
gam.check(model_OSA_atel)
```

### Adjusted model    
Fit model adjusted for confounders:   
```{r}
model_adj<-gam(spo2_fraction~s(BMI,k=5)+sex+age+sleep_apnea+hb+altitude_cat,
               data=datamodel, 
               na.action=na.omit, 
               family = quasibinomial(link = logit)
               )

R2_adj <- summary(model_adj)$r.sq
dev_adj <- summary(model_adj)$dev.expl

summary(model_adj)
plot(model_adj, all.terms=TRUE)
```

```{r}
gam.check(model_adj)
```

### Adjusted + Atelectasis percent
Fit adjusted model plus atelectasis percentage:       
```{r}
model_plus<-gam(spo2_fraction ~ s(BMI,k=5) +
                  sex + age + sleep_apnea + hb + altitude_cat +
                  atelectasis_percent,
                data=datamodel, 
                na.action=na.omit, 
                family = quasibinomial(link = logit)
                )

R2_plus <- summary(model_plus)$r.sq
dev_plus <- summary(model_plus)$dev.expl

summary(model_plus)
plot(model_plus, all.terms=TRUE)
```

```{r}
gam.check(model_plus)
```


Build a dataframe to compare models:  
```{r}
models <- data.frame(Model = c("empty",
                               "sBMI",
                               "OSA_only",
                               "atel_only",
                               "sBMI_atel",
                               "sBMI_OSA",
                               "sBMI_atel_OSA",
                               "adjusted",
                               "adjusted_plus_atel"),
                     aR2 = c(R2_empty,
                             R2_BMI,
                             R2_OSA_only,
                             R2_atel_only,
                             R2_atel,
                             R2_OSA,
                             R2_OSA_atel,
                             R2_adj,
                             R2_plus),
                     dev = c(dev_empty,
                             dev_BMI,
                             dev_OSA_only,
                             dev_atel_only,
                             dev_atel,
                             dev_OSA,
                             dev_OSA_atel,
                             dev_adj,
                             dev_plus)
           )
```

Sort by deviance   
```{r}
models <- models %>% mutate(aR2 = round(aR2,3)*100,
                            dev = round(dev,3)*100
                            )
models %>% arrange(desc(dev))
```

Sort by R2
```{r}
models %>% arrange(desc(aR2))
```

### Table S3
Create table for models:    
```{r}
tab_BMI_only <- tbl_regression(model_BMI, 
                               exponentiate = TRUE, 
                               tidy_fun = gtsummary::tidy_gam)

tab_OSA_only <- tbl_regression(model_OSA_only, 
                               exponentiate = TRUE, 
                               tidy_fun = gtsummary::tidy_gam)

tab_atel_only <- tbl_regression(model_atel_only,
                                exponentiate = TRUE,
                                tidy_fun = gtsummary::tidy_gam) 

tab_OSA <- tbl_regression(model_OSA,
                          exponentiate = TRUE, 
                          tidy_fun = gtsummary::tidy_gam) 

tab_atel <- tbl_regression(model_atel, 
                           exponentiate = TRUE,
                           tidy_fun = gtsummary::tidy_gam)

tab_OSA_atel <- tbl_regression(model_OSA_atel,
                               exponentiate = TRUE, 
                               tidy_fun = gtsummary::tidy_gam)

tab_adj <- tbl_regression(model_adj, 
                          exponentiate = TRUE,
                          tidy_fun = gtsummary::tidy_gam)

tab_plus <- tbl_regression(model_plus,
                           exponentiate = TRUE, 
                           tidy_fun = gtsummary::tidy_gam)

tableS3 <- tbl_stack(
  list(tab_BMI_only,tab_OSA_only,tab_atel_only,tab_OSA,tab_atel,tab_OSA_atel,tab_adj,tab_plus),
  group_header = c("BMI only", "OSA only", "Atelectasis percent only", "BMI + OSA", "BMI + Atelectasis percent", "BMI + OSA + Atelectasis percent", "BMI + OSA + age + sex + hb + altitude","Fully adjusted model")
  ) 

tableS3
```

Save Table S3     
```{r}
tableS3 %>%
  as_gt() %>%
  gt::gtsave(filename = "TableS3.docx", path = tabfolder)
```


### Figure SpO2:   

#### Figure 3a: sBMI  

Check residuals:   
```{r}
draw(model_BMI,residuals=TRUE) 
```


Now, plot take the inverse logit function to assess partial effect on mean SpO2.   
```{r}
draw(model_BMI, 
     constant = coef(model_BMI)[1], 
     fun = inv_link(model_BMI)
     ) 
```

Draw a personalized plot:  
```{r}
plot3a <- draw(model_BMI, 
     constant = coef(model_BMI)[1], 
     fun = inv_link(model_BMI), 
     smooth_col = "cadetblue4"
     ) +
  scale_y_continuous(labels = scales::percent, limits=c(0.80,1)) +
  labs(x="Body mass index (kg/m²)", 
       y = "Partial effect (mean SpO2)", 
       title = "s(BMI)", 
       subtitle=paste0("Deviance explained:"," ",(round(dev_BMI,3)*100),"%"),
       tag="A",
       caption=NULL) + 
  theme_bw() +
  theme(panel.border = element_blank(),
        panel.grid.minor = element_blank(), 
        axis.line = element_line(colour = "black"),
        axis.text.x = element_text(size=rel(1.2)), 
        axis.text.y = element_text(size=rel(1.2))
        )

plot3a 
```


#### Figure 3b: sBMI_OSA  

Check residuals:   
```{r}
draw(model_OSA,residuals=TRUE) 
```

Partial effect on mean SpO2:  
```{r}
plot3b <- draw(model_OSA, 
     constant = coef(model_OSA)[1], 
     fun = inv_link(model_OSA), 
     smooth_col = "cadetblue4"
     ) +
  scale_y_continuous(labels = scales::percent, limits=c(0.80,1)) +
  labs(x="Body mass index (kg/m²)", 
       y = "Partial effect (mean SpO2)", 
       title = "s(BMI) + OSA", 
       subtitle=paste0("Deviance explained:"," ",(round(dev_OSA,3)*100),"%"),
       tag="B",
       caption=NULL) + 
  theme_bw() +
  theme(panel.border = element_blank(),
        panel.grid.minor = element_blank(), 
        axis.line = element_line(colour = "black"),
        axis.text.x = element_text(size=rel(1.2)), 
        axis.text.y = element_text(size=rel(1.2))
        )

plot3b 
```


#### Figure 3c: sBMI_atel  

Check residuals:   
```{r}
draw(model_atel,residuals=TRUE) 
```

Partial effect on mean SpO2:  
```{r}
plot3c <- draw(model_atel, 
     constant = coef(model_atel)[1], 
     fun = inv_link(model_atel), 
     smooth_col = "cadetblue4"
     ) +
  scale_y_continuous(labels = scales::percent, limits=c(0.80,1)) +
  labs(x="Body mass index (kg/m²)", 
       y = "Partial effect (mean SpO2)", 
       title = "s(BMI) + atelectasis percent", 
       subtitle=paste0("Deviance explained:"," ",(round(dev_atel,3)*100),"%"),
       tag="C",
       caption=NULL) + 
  theme_bw() +
  theme(panel.border = element_blank(),
        panel.grid.minor = element_blank(), 
        axis.line = element_line(colour = "black"),
        axis.text.x = element_text(size=rel(1.2)), 
        axis.text.y = element_text(size=rel(1.2))
        )

plot3c 
```

#### Figure 3d: fully adjusted 

Check residuals:   
```{r}
draw(model_plus,residuals=TRUE) 
```

Partial effect on mean SpO2:  
```{r}
plot3d <- draw(model_plus, 
     constant = coef(model_plus)[1], 
     fun = inv_link(model_plus), 
     smooth_col = "cadetblue4"
     ) +
  scale_y_continuous(labels = scales::percent, limits=c(0.80,1)) +
  labs(x="Body mass index (kg/m²)", 
       y = "Partial effect (mean SpO2)", 
       title = "Fully adjusted model", 
       subtitle=paste0("Deviance explained:"," ",(round(dev_plus,3)*100),"%"),
       tag="D",
       caption=NULL) + 
  theme_bw() +
  theme(panel.border = element_blank(),
        panel.grid.minor = element_blank(), 
        axis.line = element_line(colour = "black"),
        axis.text.x = element_text(size=rel(1.2)), 
        axis.text.y = element_text(size=rel(1.2))
        )

plot3d 
```

#### Figure 3   
```{r}
figure3 <- grid.arrange(plot3a, plot3b, plot3c, plot3d)
```

Save figure:   
```{r}
ggsave("Figure3.png",plot=figure3,path=figfolder, width = 10,  height = 7, units = "in", dpi = 300)
```


```{r, include = FALSE}
rm(sm,dataOSA,dataBMIs,dataATEL,dataPLUS,figure3,tableS3)
rm(list=setdiff(ls(pattern = "^plot3"), lsf.str()))
rm(list=setdiff(ls(pattern = "^dev"), lsf.str()))
rm(list=setdiff(ls(pattern = "^model"), lsf.str()))
rm(list=setdiff(ls(pattern = "^R2"), lsf.str()))
rm(list=setdiff(ls(pattern = "^tab_"), lsf.str()))
```

# Post-hoc analyses  

In figure 2, it can be observed that SpO2 starts decreasing at BMIs above 40. Thus, by having used the WHO obesity class categories, detail on differences above BMI 40 for the extent of atelectasis percentage may have been lost. The WHO obesity class categories do not reflect the extent of variation in BMI observed in this sample of patients:   
- Class 1, BMI [30,35): ~1/4 participants   
- Class 2, BMI [35,40): ~1/4 participants   
- Class 3, BMI >40: ~1/2 of participants, with a median BMI above a 5 units range: `r data %>% filter(type_obesity=="Class 3 Obesity") %>% summarize(BMI=median(BMI))`.  

Thus, creating subcategories within the class 3 obesity may allow to assess the impact of BMI increases above 40 on atelectasis percentage with more detail.   

Create new variable with the following categories:  
- BMI [30,35)      
- BMI [35,40)    
- BMI [40,45)    
- BMI [44,50)    
- BMI >50    

```{r}
data_prop <- data_prop %>% 
  mutate(BMI_breaks = cut(BMI,
                            breaks=c(30,35,40,45,50,80),
                            right=FALSE,
                            labels=c("[30,35)","[35,40)","[40,45)","[45,50)","≥50")
                            )
         )
```


```{r}
attach(data_prop)
tab <- table(BMI_breaks)
tab
prop <- round(prop.table(tab)*100,1)
prop
```

## Atelectasis - obesity breaks       

Mean expected frequency:  
```{r}
mean_exp <- data_prop %>% summarize(mean_expected_freq = n()/(nlevels(BMI_breaks)*nlevels(atelectasis)))
mean_exp
```

```{r}
freq <- table(BMI_breaks, atelectasis)
freq
round(prop.table(freq),4)
```

Mosaic Plot  
```{r, fig.height=4, fig.width=6}
data_prop %>% mutate(atelectasis = fct_relevel(atelectasis, "No", "Yes")) %>%
ggplot() +
  geom_mosaic(aes(x = product(atelectasis,BMI_breaks), fill=atelectasis),na.rm = TRUE) +
  scale_fill_manual(values=c("grey95","lightsteelblue4")) +
  theme_mosaic() + 
  theme(axis.text.x=element_text(size=rel(0.8)))
```


```{r}
chi <- chisq.test(freq, correct=FALSE)
chi
```

```{r, include=FALSE}
rm(mean_exp,freq, chi)
```


#### Atelectasis location by obesity class   

Mean expected frequency:  
```{r}
mean_exp <- data_prop %>% drop_na(BMI_breaks, atelectasis_location) %>% summarize(mean_expected_freq = n()/(nlevels(BMI_breaks)*nlevels(atelectasis_location)))
mean_exp
```

Mean expected frequency is greater than 5.0, so chi-squared without continuity correction is adequate.  

```{r}
freq <- table(BMI_breaks, atelectasis_location)
freq
round(prop.table(freq),4)
```

Mosaic Plot  
```{r, fig.height=3, fig.width=5}
ggplot(data_prop = data_prop) +
  geom_mosaic(aes(x = product(BMI_breaks,atelectasis_location), fill=BMI_breaks),na.rm = TRUE) +
  scale_fill_manual(values=c("seagreen1","seagreen2","seagreen3","seagreen4","seagreen")) +
  theme_mosaic() 
```


```{r}
chi <- chisq.test(freq, correct=FALSE)
chi
```


```{r}
#Patients who had atelectasis (Yes/No)
atelectasis_total <- data_prop %>% group_by(atelectasis) %>% 
  summarise(n = n()) %>%  
  mutate(prev = n / sum(n)*100, 
         lower = lapply(n, prop.test, n = sum(n)), 
         upper = sapply(lower, function(x) x$conf.int[2])*100, 
         lower = sapply(lower, function(x) x$conf.int[1])*100,
         BMI_breaks = "Total") %>% 
  mutate_at(3:5, round, 2)
atelectasis_total$confint <- paste(atelectasis_total$lower, "-", atelectasis_total$upper)
atelectasis_total <- atelectasis_total %>% dplyr::select(-c(lower,upper))

atelectasis_obesity <- data_prop %>% group_by(BMI_breaks, atelectasis) %>% 
  summarise(n = n()) %>%  
  mutate(prev = n / sum(n)*100, 
         lower = lapply(n, prop.test, n = sum(n)), 
         upper = sapply(lower, function(x) x$conf.int[2])*100, 
         lower = sapply(lower, function(x) x$conf.int[1])*100) %>% 
  mutate_at(4:6, round, 2)
atelectasis_obesity$confint <- paste(atelectasis_obesity$lower, "-", atelectasis_obesity$upper)
atelectasis_obesity <- atelectasis_obesity %>% dplyr::select(-c(lower,upper))


atelectasis <- atelectasis_total %>% bind_rows(atelectasis_obesity) %>% relocate(BMI_breaks, .before = n)


#Location of atelectasis (Unilateral/Bilateral)
atelectasis_total_location <- data_prop %>% filter(atelectasis=="Yes") %>% group_by(atelectasis_location) %>% summarise(Freq = n()) %>%  mutate(Percentage = (round((Freq/sum(Freq)*100),digits=2)), BMI_breaks = "Total")
atelectasis_total_location$sumpercent <- paste(atelectasis_total_location$Freq," (", atelectasis_total_location$Percentage, "%)")
atelectasis_total_location <- atelectasis_total_location %>% dplyr::select(-c(Freq,Percentage)) %>% pivot_wider(names_from = atelectasis_location,values_from = sumpercent)
                                                                                                                         
atelectasis_obesity_location <- data_prop %>% filter(atelectasis=="Yes") %>% group_by(BMI_breaks, atelectasis_location) %>% summarise(Freq = n()) %>%  mutate(Percentage = (round((Freq/sum(Freq)*100),digits=2)))
atelectasis_obesity_location$sumpercent <- paste(atelectasis_obesity_location$Freq," (", atelectasis_obesity_location$Percentage, "%)")
atelectasis_obesity_location <- atelectasis_obesity_location %>% dplyr::select(-c(Freq,Percentage)) %>% pivot_wider(names_from = atelectasis_location,values_from = sumpercent)

location <- atelectasis_total_location %>% bind_rows(atelectasis_obesity_location)

atelectasis <- atelectasis %>% right_join(location,by="BMI_breaks") %>% mutate(confint=replace(confint, atelectasis=="No", NA), Unilateral=replace(Unilateral, atelectasis=="No", NA), Bilateral=replace(Bilateral, atelectasis=="No", NA))
atelectasis

```


```{r, include=FALSE}
rm(mean_exp, freq, chi, location, atelectasis_obesity, atelectasis_total, atelectasis_total_location, atelectasis_obesity_location, atelectasis)
```



#### Atelectasis Percent 

##### Mean atelectasis percentage  

Mean atelectasis percentage coverage by BMI breaks:   

If ignoring zero-inflation and skewness:    
```{r}
data %>% mutate(BMI_breaks = cut(BMI,breaks=c(30,35,40,45,50,80),right=FALSE,
                                     labels=c("[30,35)","[35,40)","[40,45)","[45,50)","≥50")),
                    atelectasis_percent=as.numeric(atelectasis_percent)) %>% 
  group_by(BMI_breaks) %>%
  summarize(
    mean = mean(atelectasis_percent),
    sd = sd(atelectasis_percent)
  ) 
```

As is evident from these numbers, assuming normality causes standard deviation to capture negative values, which is impossible in reality for this variable.   

Thus, bootstrapping mean and 95%CI is expected to lead to more appropriate estimates:   
```{r}
data_class_1 <- data %>% 
  mutate(BMI_breaks = cut(BMI,breaks=c(30,35,40,45,50,80),right=FALSE,
                                     labels=c("[30,35)","[35,40)","[40,45)","[45,50)","≥50")),
         atelectasis_percent=as.numeric(atelectasis_percent)) %>% 
  group_by(BMI_breaks) %>%
  filter(BMI_breaks=="[40,45)") 


data_class_2 <- data %>% 
  mutate(BMI_breaks = cut(BMI,breaks=c(30,35,40,45,50,80),right=FALSE,
                                     labels=c("[30,35)","[35,40)","[40,45)","[45,50)","≥50")),
         atelectasis_percent=as.numeric(atelectasis_percent)) %>% 
  group_by(BMI_breaks) %>% 
  filter(BMI_breaks=="[45,50)") 


data_class_3 <- data %>% 
  mutate(BMI_breaks = cut(BMI,breaks=c(30,35,40,45,50,80),right=FALSE,
                                     labels=c("[30,35)","[35,40)","[40,45)","[45,50)","≥50")),
         atelectasis_percent=as.numeric(atelectasis_percent)) %>% 
  group_by(BMI_breaks) %>% 
  filter(BMI_breaks=="≥50") 
```

BMI [40,45)    
```{r}
boot_class1 <- one.boot(data_class_1$atelectasis_percent, mean, R=10000)
mean_boot_class1 <- mean(boot_class1$t)
mean_boot_class1
boot_ci_class1 <- boot.ci(boot_class1)
boot_ci_class1
```

BMI [44,50)    
```{r}
boot_class2 <- one.boot(data_class_2$atelectasis_percent, mean, R=10000)
mean_boot_class2 <- mean(boot_class2$t)
mean_boot_class2
boot_ci_class2 <- boot.ci(boot_class2)
boot_ci_class2
```

- BMI >50  
```{r}
boot_class3 <- one.boot(data_class_3$atelectasis_percent, mean, R=10000)
mean_boot_class3 <- mean(boot_class3$t)
mean_boot_class3
boot_ci_class3 <- boot.ci(boot_class3)
boot_ci_class3
```

> The mean atelectasis percentage according to class 3 subgroups was: BMI [40,45)  (`r round(mean_boot_class1,2)`%, 95%CI:`r round(boot_ci_class1$bca[1,4],2)`-`r round(boot_ci_class1$bca[1,5],2)`), BMI [44,50) (`r round(mean_boot_class2,2)`%, 95%CI:`r round(boot_ci_class2$bca[1,4],2)`-`r round(boot_ci_class2$bca[1,5],2)`), and BMI >50 (`r round(mean_boot_class3,2)`%, 95%CI:`r round(boot_ci_class3$bca[1,4],2)`-`r round(boot_ci_class3$bca[1,5],2)`).

```{r, include=FALSE}
rm(boot_atel,mean_boot,boot_ci,data_class_1,data_class_2,data_class_3,boot_class1,mean_boot_class1,boot_ci_class1,boot_class2,mean_boot_class2,boot_ci_class2,boot_class3,mean_boot_class3,boot_ci_class3)
```


Mean expected frequency:  
```{r}
mean_exp <- data_prop %>% mutate(atelectasis_percent=factor(atelectasis_percent)) %>% summarize(mean_expected_freq = n()/(nlevels(BMI_breaks)*nlevels(atelectasis_percent)))
mean_exp
```

Mean expected frequency is greater than 5.0, so chi-squared without continuity correction is adequate.  

```{r}
tab <- table(atelectasis_percent,type_obesity)
tab
prop.table(tab)
prop_fig2a <- prop.table(tab,margin=2)
prop_fig2a
```

```{r}
tab <- table(atelectasis_percent,BMI_breaks)
tab
prop.table(tab)
prop_fig2b <- prop.table(tab,margin=2)
prop_fig2b
```

```{r}
barplot(tab,beside=TRUE)
```

```{r}
chi <- chisq.test(tab, correct=FALSE)
chi
```


> The relative frequencies of atelectasis percentage according to BMI breaks were significantly different (**Figure 2b**, p<0.001).   

##### Figure 2b  
```{r}
barplot(prop_fig2b,beside=TRUE,ylim=c(0,1),xlim=c(0,34),ylab="Relative frequency",xlab="Body mass index (kg/m²)",
        col=brewer.pal(4,"Blues"),
        legend.text=c("0-5%","5-10%","10-15%","≥15%"),
        space = c(0.2, 1.5)
        )
Figure2b <- recordPlot()
```    

```{r, results='hide'}
png(filename=paste(figfolder,"/Figure2b.png",sep=""),width=8, height=5, units="in", res=300)
Figure2b
dev.off
```


I only want to show frequencies for the subcategories of class 3 obesity.  
```{r}
prop_fig2b <- prop_fig2b[1:4,3:5]
```

Rebuild plots and stack them: 
```{r}
layout(matrix(c(1,2), ncol=2), widths=c(5,5))
par(mgp=c(0,2,0))  
barplot(prop_fig2a,beside=TRUE,ylim=c(0,1),yaxt='n',
        main="A",adj=0,
        names.arg=expression(atop("[30,35)","Class 1"),atop("[35,40)","Class 2"),atop("≥40","Class 3")),
        col=brewer.pal(4,"Blues"),
        space = c(0.2, 1.5), 
        cex.axis = 0.9, cex.names = 0.9
        )
axis(2, at=0.5, pos=0, labels="Relative frequency", las=0, tck=0, lwd=0)
axis(2, at=c(0.0,0.2,0.4,0.6,0.8,1.0), labels=FALSE)
axis(2, at=c(0.0,0.2,0.4,0.6,0.8,1.0), labels=c("0.0","0.2","0.4","0.6","0.8","1.0"), pos=3, tck=0, lwd=0, cex.axis=0.9)
par(mgp=c(2,0.5,0)) 
barplot(prop_fig2b,beside=TRUE,ylim=c(0,1),
        main="B",adj=0,
        xlab="         Class 3 subgroups (kg/m²)", cex.lab = 0.9,
        col=brewer.pal(4,"Blues"),
        legend.text=c("0-5%","5-10%","10-15%","≥15%"), args.legend = c(y=1.1,cex=0.8),
        space = c(0.2, 1.5), 
        cex.axis = 0.9, cex.names = 0.9
        )

Figure2 <- recordPlot() 
```


```{r, results='hide'}
png(filename=paste(figfolder,"/Figure2.png",sep=""),width=8, height=5, units="in", res=300)
Figure2
dev.off
```

```{r, include=FALSE}
rm(mean_exp,freq,percent,tab,chi,Figure2,Figure2b,prop_fig2a,prop_fig2b)
```


## Crude prevalence ratio   
```{r}
dataprev <- data_prop %>% mutate(atelectasis = as.numeric(as.character(fct_recode(atelectasis,"0"="No","1"="Yes"))))

poisson_fit <- glm(atelectasis ~ BMI_breaks,
data = dataprev,
family = poisson(link = log))

tidy(poisson_fit, exponentiate = TRUE, conf.int = TRUE)
```

Robust standard errors:  
```{r}
covmat <- vcovHC(poisson_fit, type = "HC0")
covmat
```

```{r}
#Calculate the standard error
se <- sqrt(diag(covmat))

# Bind together model output
#  1. exponentiated coefficients
#  2. robust standard errors
#  3. 95% confidence intervals
# Note that qnorm(0.975) approximately equals 1.96
model_output <- cbind(
  Estimate = exp(coef(poisson_fit)),
  `Robust SE` = se,
  Lower = exp(coef(poisson_fit) - qnorm(0.975) * se),
  Upper = exp(coef(poisson_fit) + qnorm(0.975) * se)
)

# Coerce model_output into a data frame
# Return second row to focus on the weekheart variable
model_output <- as.data.frame(round(model_output,2))
model_output


```

## Adjusted prevalence ratio   
```{r}
poisson_fit <- glm(atelectasis ~ BMI_breaks + age + sex + sleep_apnea,
data = dataprev,
family = poisson(link = log))

tidy(poisson_fit, exponentiate = TRUE, conf.int = TRUE)
```

Robust standard errors:  
```{r}
covmat <- vcovHC(poisson_fit, type = "HC0")
covmat
```

```{r}
#Calculate the standard error
se <- sqrt(diag(covmat))

# Bind together model output
#  1. exponentiated coefficients
#  2. robust standard errors
#  3. 95% confidence intervals
# Note that qnorm(0.975) approximately equals 1.96
model_output2 <- cbind(
  Estimate = exp(coef(poisson_fit)),
  `Robust SE` = se,
  Lower = exp(coef(poisson_fit) - qnorm(0.975) * se),
  Upper = exp(coef(poisson_fit) + qnorm(0.975) * se)
)

# Coerce model_output into a data frame
# Return second row to focus on the weekheart variable
model_output2 <- as.data.frame(round(model_output2,2))
model_output2
```

### Table 2   
```{r}
model_output <- model_output %>% 
  dplyr::slice(2:5) %>%
  rename(PR = Estimate, SE = `Robust SE`) %>% 
  mutate("95%CI" = paste(Lower,Upper,sep="-")) %>% 
  select(-c(Lower,Upper))

model_output2 <- model_output2 %>% 
  dplyr::slice(2:5) %>%
  rename(aPR = Estimate, aSE = `Robust SE`) %>% 
  mutate("a95%CI" = paste(Lower,Upper,sep="-")) %>% 
  select(-c(Lower,Upper))

table2 <- dplyr::bind_cols(model_output, model_output2) %>% rownames_to_column(var = "Category") %>% mutate_at("Category", str_replace, "BMI_breaks", "")

flextable(table2) %>% 
  save_as_docx(path = paste(tabfolder,"/Table2_complement.docx",sep=""))

table2
```


```{r, include=FALSE}
rm(dataprev,poisson_fit,covmat,se,model_output, model_output2,table2)
```




## Ordinal Logistic Regression Model   

Collapse atelectasis percent category as done before:    
```{r}
dataposthoc <- data_prop
dataposthoc$atelectasis_percent <- fct_collapse(dataposthoc$atelectasis_percent,
                                              "0%" = c("0%","2.5%"),
                                              "5%" = c("5%","7.5%"),
                                              "10%" = c("10%","12.5%"),
                                              "15%" = c("15%","17.5%")
                                              )

table(dataposthoc$atelectasis_percent)
```


Rename new obesity category breaks levels to facilitate reading of results:  
```{r}
dataposthoc <- dataposthoc %>% 
  mutate(BMI_breaks=fct_recode(BMI_breaks, 
                               "1"="[30,35)", 
                               "2"="[35,40)", 
                               "3"="[40,45)",
                               "4"="[45,50)",
                               "5"="≥50"),
         atelectasis_percent=ordered(atelectasis_percent)) 
```

Visualize pattern of atelectasis percent increase by obesity type category. 
```{r}
dataposthoc %>% 
  ggplot(aes(x = BMI_breaks, fill = atelectasis_percent)) + 
  geom_bar() +
  scale_fill_manual(values = brewer.pal(5,"Blues")) +
  theme_minimal()
```


The **loglog** link function will be used since this distribution provides the best fit for the fully adjusted ordinal model:   

```{r}
dataposthoc %>%
  nest(data = everything()) %>%
 crossing(
    link = c("logit", "probit", "cloglog", "loglog", "cauchit"),
    threshold = c("flexible", "equidistant")
  ) %>%
  mutate(
    mod = map2(
      data, link,
      ~clm(atelectasis_percent ~ BMI_breaks + sex + age + sleep_apnea, 
        data = .x, link = .y
      )
    )
  ) %>%
  mutate(
    mod_summary = map(
      mod,
      ~glance(.x) %>% mutate(logLik = as.numeric(logLik))
    )
  ) %>%
  unnest(mod_summary) %>%
  dplyr::select(link, threshold, logLik, edf, AIC, BIC) %>%
  arrange(logLik) %>%
  gt()
```


```{r, warning=TRUE}
fit_uni <- clm(atelectasis_percent ~ BMI_breaks, data = dataposthoc, link = "loglog", threshold = "flexible")

summary(fit_uni)
```

Note that AIC (275.92) improved very much respect to initial univariable model with conventional BMI categories (391.33).

```{r, warning=TRUE}
nominal_test(fit_uni, trace=TRUE)
```

Traceback of nominal_test function showed failure to converge (error code -1), similar to what happened with first model. Will fit model with nominal term and compare through ANOVA:    

```{r, warning=TRUE}
fit_BMInom <- clm(atelectasis_percent ~ 1, nominal= ~ BMI_breaks, data = dataposthoc, link = "loglog", threshold = "flexible")

summary(fit_BMInom)
```


```{r, warning=TRUE}
anova(fit_uni,fit_BMInom)
```

Model with nominal term did not converge. Thus, I will only present ordinal model.       

```{r}
uni_BMI_breaks <- tidy(fit_uni, conf.int = T, conf.type = "Wald") %>%
  transmute(
    term, across(c(estimate, conf.low, conf.high), exp)
  ) %>%
  gt() %>%
  fmt_number(c(estimate, conf.low, conf.high), decimals = 2) %>% 
  cols_merge(c(conf.low, conf.high),
             pattern = "{1}&mdash;{2}") %>% 
   cols_label(conf.low = "95%CI")

uni_BMI_breaks
```



### Multivariable model   

```{r, warning=TRUE}
fit_multi <- clm(atelectasis_percent ~ BMI_breaks + age + sex + sleep_apnea, data = dataposthoc, link = "loglog", threshold = "flexible")

summary(fit_multi)
```

Convergence: 
```{r}
convergence(fit_multi)
```


Check proportional odds assumption:   
```{r, warning=TRUE}
nominal_test(fit_multi)
```

Proportional odds OK for all variables except obesity type (as already expected) and age. Centering of age should solve this issue: 
```{r}
dataposthoc <- dataposthoc %>% mutate(agec = age/mean(age))
```

Re-fit model:    
```{r, warning=TRUE}
fit_multi2 <- clm(atelectasis_percent ~ BMI_breaks + agec + sex + sleep_apnea, data = dataposthoc, link = "loglog", threshold = "flexible")

summary(fit_multi2)
```

Convergence: 
```{r}
convergence(fit_multi2)
```


Check proportional odds assumption:   
```{r, warning=TRUE}
nominal_test(fit_multi2)
```

Issue not solved. Will report uncentered age as proportional odds assumption is not as relevant for covariates.   

Check for scale effects:    
```{r}
scale_test(fit_multi2)
```

No scale effects.   

Summarize results of first model in table:   
```{r}
tidy(fit_multi, conf.int = T, conf.type = "Wald") %>%
  transmute(
    term, across(c(estimate, conf.low, conf.high), exp)
  ) %>%
  gt() %>%
  fmt_number(c(estimate, conf.low, conf.high), decimals = 2) %>% 
  cols_merge(c(conf.low, conf.high),
             pattern = "{1}&mdash;{2}") %>% 
  cols_label(conf.low = "95%CI")
```


```{r, include=FALSE}
rm(fit_multi, fit_multi2, fit_uni, uni_BMI_breaks, fit_BMInom)
```


## Partial proportional odds model   


The **probit** link function will be used since this distribution provides the best fit for the fully adjusted model with nominal BMI terms:   

```{r}
dataposthoc %>%
  nest(data = everything()) %>%
 crossing(
    link = c("logit", "probit", "cloglog", "loglog", "cauchit"),
    threshold = c("flexible", "equidistant")
  ) %>%
  mutate(
    mod = map2(
      data, link,
      ~clm(atelectasis_percent ~ sex + age + sleep_apnea, nominal = ~ BMI_breaks,
        data = .x, link = .y
      )
    )
  ) %>%
  mutate(
    mod_summary = map(
      mod,
      ~glance(.x) %>% mutate(logLik = as.numeric(logLik))
    )
  ) %>%
  unnest(mod_summary) %>%
  dplyr::select(link, threshold, logLik, edf, AIC, BIC) %>%
  arrange(logLik) %>%
  gt()
```



#### Multivariable model  
Fit a model that allows proportional odds for all explanatory variables, except BMI breaks:    
```{r}
fit_BMIpart <- vglm(atelectasis_percent ~ BMI_breaks+sleep_apnea+sex+agec, data=dataposthoc, link="probit", family=cumulative(parallel=FALSE~BMI_breaks, reverse = TRUE))

summary(fit_BMIpart)
```



```{r}
confint_BMIpart <- round(exp(confintvglm(fit_BMIpart,method = "wald")),2)
confint_BMIpart
```

Hauck-Donner effect leading to unreliable estumates. Thus, will not report this model.   

```{r, include=FALSE}
rm(fit_BMIpart, confint_BMIpart,confint_BMIpartuni)
```

